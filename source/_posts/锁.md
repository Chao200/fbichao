---
title: 锁
tags:
  - 锁
  - 死锁
author: fbichao
categories: 
  - 操作系统
  - 并发
excerpt: 锁相关
math: true
date: 2024-03-11 21:45:00
---
# 1. 介绍一下你所知道的锁

锁是为了实现对临界资源的互斥访问，从而实现并发安全，我了解的锁有互斥锁、自旋锁、读写锁、悲观锁、乐观锁、睡眠锁

**互斥锁**只有两种状态，上锁和解锁，互斥锁加锁失败，线程会释放 CPU 给其它线程

**自旋锁**与互斥锁类似，不同之处在于，互斥锁加锁失败，会一直忙等待，直到得到锁；自旋锁适用于对锁的持有时间较短的场景，在内核中常用，但是自旋锁没有公平性可言，可能会导致别的线程饿死，单 CPU 下开销很大，在多 CPU 下，效果不错

**读写锁**如果某个线程申请了读锁，其它线程只能申请读锁，不能申请写锁；如果某个线程申请了写锁，其它线程不能申请读写锁

**悲观锁**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。

**乐观锁**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。没有加锁

`<mark style="background: #FF5582A6;">`**睡眠锁**有时我们需要 `</mark>`

```
两阶段锁
> 循环固定自旋次数，再休眠
- 第一个自旋阶段
- 如果自旋阶段没得到锁，调用者会休眠，直到锁可用
```

# 2. 什么情况会产生死锁

死锁就是多个进程在持有部分资源的前提下，还需要对方所持有的资源，就会产生死锁

必要条件

- 互斥：多个线程不能同时使用一个共享资源
- 持有并等待：线程持有资源还会等待其他所需资源，不会主动释放
- 非抢占：无法抢占别的线程持有的资源
- 循环等待：多个线程获取资源的顺序构成环路

# 3. 如何解除死锁

## 3.1 循环等待

让线程获取资源按照一定顺序，~~即全序、偏序~~

通过锁的地址顺序，比如按照地址从高到低顺序加锁

## 3.2 持有并等待

一次申请所有需要的资源

## 3.3 非抢占

调用 trylock() 函数尝试获得锁，如果得不到，就释放自身占有的锁

活锁问题：一直循环占有一个锁，随后释放
解决活锁：循环结束，设置一个随机的等待时间

## 3.4 互斥

完全避免互斥

设计无等待数据结构，通过硬件指令，构造出不需要锁的数据结构

比较并交换（compare and swap）指令
同样可能会产生活锁问题

## 3.5 检查和恢复

允许死锁偶尔发生，检查到了死锁再采取行动

## 3.6 避免死锁

通过调度，银行家算法，如果当前对资源的操作，导致后续会产生死锁，则回退
