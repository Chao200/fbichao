---
title: 事务隔离
tags:
  - 事务隔离
author: fbichao
categories: 
  - MySQL
  - 事务
excerpt: 事务
math: true
date: 2024-03-21 21:45:00
---
![](https://file.fbichao.top/2024/03/e852a99bec52eae968cdb1a40525ab7e.png)
# 事务四大特性

- 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节
- 一致性（Consistency）：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态
- 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致
- 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 1. 如何实现四大特性？

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性是通过 持久性 + 原子性 + 隔离性来保证；

# 并行事务引发的问题

- 脏读：读到其他事务未提交的数据；
- 不可重复读：前后读取的数据不一致；
- 幻读：前后读取的记录数量不一致。

## 1. 脏读（dirty read）

如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。

## 2. 不可重复读（non-repeatable read）

在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。

## 3. 幻读（phantom read）

在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。

# 事务隔离

![](https://file.fbichao.top/2024/03/805f0ef6fea55aefe93f47d0c71ffbe5.png)

- 读未提交（read uncommitted），指一个事务还**没提交**时，它做的变更就能被其他事务看到；
- 读提交（read committed），指一个事务**提交之**后，它做的变更才能被其他事务看到；
- 可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；
- 串行化（serializable ），会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象

# 四种隔离级别如何实现？

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取**最新**的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加**读写锁**的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View** 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在 **「每个语句执行前」** 都会重新生成一个 Read View，而「可重复读」隔离级别是 **「启动事务时」** 生成一个 Read View，然后整个事务期间都在用这个 Read View。

# RR 隔离下如何解决幻读

- 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的
- 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

> 开启事务之后，马上执行 select ... for update 这类当前读的语句来避免幻读

# Read View 在 MVCC 中如何工作

> MVCC = Read View + undo log

Read View
![](https://file.fbichao.top/2024/03/9784835218f9efe79c7360ab92ba868c.png)

记录中隐藏的列
![](https://file.fbichao.top/2024/03/8800dbe039194119fcfeb3cec08f486d.png)

trx_id：一个列记录对记录进行改动的事务 ID
一个列记录回滚指针

![](https://file.fbichao.top/2024/03/aaa848479da85d290ce62af1d910d097.png)

- 当 trx_id 小于最小索引，则可见
- 当 trx_id 大于等于最大索引，则不可见
- 在其间，trx_id 如果不在列表中，则可见，否则不可见

# RR 工作原理

- 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。

# RC 工作原理

- 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。
