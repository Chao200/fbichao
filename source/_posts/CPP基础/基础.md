---
title: CPP基础
tags:
  - CPP
  - 基础
author: fbichao
categories: 
  - CPP
excerpt: CPP
math: true
date: 2024-03-21 21:45:00
---

## 指针和引用

- 指针是对象，而引用不是
- 指针既可以修改本身所指对象，也可以修改所指对象的内容（无 const 修饰），而引用初始化后不可以改变
- 有空指针，无空引用
- 指针可以先声明，后初始化，而引用定义时必须初始化
- sizeof 指针得到的是本指针的大小，sizeof 引用得到的是引用所指向变量的大小
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。

## 常量指针和指针常量

> 《C++ Primer》中是如此规定

- 常量指针

    ```C++
    // 本身是 const，即顶层 const，需要初始化
    int* const p
    ```

- 指针常量（指向常量的指针）

    ```C++
    // 所指对象是 const，底层 const
    const int* p;
    ```


## static

### 1. 保持内容持久

- 在程序刚开始运行时就完成初始化，也是唯一的一次初始化，此后直到程序退出，一直存在

### 2. 函数和变量

- 当同时编译多个文件时，所有 **未加static** 前缀的 *全局变量* 和 *函数* 都具有全局可见性。

### 3. 函数内部

- 作用范围为该函数体，该变量的内存只被分配一次，其值在下次调用时仍维持上次的值

### 4. 静态成员函数

- 所有类对象共享一份静态成员函数，只能使用静态成员变量/函数，不可以直接调用成员函数或成员变量

> 不可以被声明 virtual
- static 不属于任何对象或实例
- 没有 this 指针查找 vptr

### 5. 静态成员变量

- 所有类对象共享一份静态成员变量

- 必须在类外单独定义


## const

- 变量：声明常量，不可改变
- 指针：[常量指针和指针常量](#常量指针和指针常量)
- 引用：常量引用，引用对象是常量，不可改变
- 成员函数：该成员函数不会改变对象的成员变量
- 成员变量：不能赋值、不能类外定义，只能通过构造函数列表初始化
- 引用参数：函数不会修改该参数
- 指针参数：指针常量，不会通过指针修改数据


## define、typedef、inline、const、constexpr

预处理--->编译--->汇编--->链接

### 1. define

- 字符串替换
- 无类型检查
- 预处理阶段完成
- 不分配内存


### 2. typedef

- 有类型检查
- 编译阶段完成
> 在静态存储区分配空间，运行过程中内存中只有一个拷贝

### 3. inline

- 将内联函数编译完成生成函数体，直接插入到调用的地方，没有普通函数调用入栈出栈等开销
- 有类型检查
- 编译阶段完成

### 4. const

- 有类型检查
- 编译阶段完成
- 存储在静态存储区


### 5. constexpr

- const 是只读，而 constexpr 是常量
- 编译器完成
- constexpr 一定是 const，反之未必




## volatile

- 修饰的变量影响编译器编译结果，表示该变量随时可能发生变化，与该变量有关的计算，不要进行编译优化，会从内存中重新装载内容，而不是从寄存器拷贝
- 每次直接读值，保证对特殊地址的稳定访问
- 若要修改 const 变量，需要加上关键字 volatile
- 若要修改 const 成员函数中某些数据成员，则需要 mutable


## extern

- 声明外部变量



## 前置++ & 后置++

- 运算符重载时，用参数标识前后缀

```C++
// 前缀++
self& operator++()
{
    node = (linktype)(node->next);
    return *this;
}
// 后缀++
const self& operator++(int)
{
    self tmp = *this;
    ++*this;        // 使用前缀++调用
    return tmp;     // 返回对象
}
```

- 后置，返回对象而不是引用

返回值是临时对象，函数结束会销毁

- 后置加 const

防止出现 i++++



## std:atomic

a++ 和 int a = b 都不是线程安全的

CPU 架构设计，数据不能直接从内存某处搬运到内存中某处，必须借助 **寄存器中转**

原子操作
```C++
std::atomic<int> value;
value = 99;
```


## 函数指针和指针函数

### 1. 函数指针
函数指针是指向函数的指针变量，存储函数的地址

定义如下
```C++
type (*type)(args)
```

- 实现多态
- 动态加载库
- 作为参数，实现回调

### 2. 指针函数

返回类型是指针


## struct 和 class

- struct 通常用于表示一组相关的数据，而 class 用于表示一个封装了数据和操作的对象
- struct 默认是 public， class 默认是 private
- struct 默认是 public 继承， class 默认是 private 继承

## 强制类型转换

### 1. static_cast

只要不包含底层 const，都可以使用

没有运行时类型检查来保证转换的安全

- 父子类之间转换
    - 上行转换（派生类转为基类指针或引用）安全
    - 下行转换（基类转为派生类指针或引用）不安全
- 基本数据类型转换
- 把任何类型的表达式转换成 void 类型
- 不能转换掉 expression 的 const、volatile 属性

### 2. dynamic_cast

用于存在虚函数的基类转为派生类指针或引用

### 3. reinterpret_cast

为运算对象的位模式提供底层上的重新解释，比如一个 int* 对象，转换为 char*

### 4. const_cast

只改变底层 const，不改变类型，所以转换的类型需要和表达式类型一致

可以用于函数重载，去掉 const 属性

- 常量指针被转化成非常量的指针，并且仍然指向原来的对象
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象


## 传递参数，使用引用、指针、值？

> 不修改加 const

- 如果数据对象很小，如 char，可以传值，需要修改传递引用
- 如果数据对象较大，使用指针或引用
- 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式
- 如果返回的数据是临时对象或局部变量，返回值
- 能使用引用不使用指针，引用不需要创建临时变量，而指针需要




