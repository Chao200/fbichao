---
title: 面向对象
tags:
  - CPP
  - 面向对象
author: fbichao
categories: 
  - CPP
excerpt: 面向对象
math: true
date: 2024-03-23 21:45:00
---

## 三大特性

封装、继承、多态


## 访问修饰符

private、public、protected

private 继承：父类全都 private
public 继承：父类不变
protected 继承：父类 public 变 protected，其余不变


## 3. 多重继承

一个类可以从多个基类继承，可能存在菱形继承问题

需要在菱形中间两个类继承基类时，使用 virtual


## 4. 重载和重写

重载：编译时多态，同名函数，函数签名不同

重写：运行时多态，子类重新实现父类虚函数，private 不可以被重写，为了避免书写错误，重写后面加上关键词 override


## 构造函数和析构函数

- 创建对象时，构造函数自动调用，目的是初始化对象的成员变量，分配资源
- 对象生命周期结束时自动调用的函数，目的是释放对象占用的资源


## 构造函数有几种？什么作用？

- 默认构造函数
- 带参数的构造函数
- 拷贝构造函数：通过已存在的对象创建一个新对象
- 委托构造函数：在一个构造函数中调用同类的另一个构造函数
- 移动构造函数：不进行复制或分配操作的情况下将一个对象的内容从一个对象移动到另一个对象中，以提高程序性能和效率


## 移动构造函数调用时机

- 用一个右值对象初始化另一个对象时。例如，将一个临时对象传递给函数参数或返回一个临时对象。

- 在函数中使用std::move函数将一个对象强制转换为右值引用。例如，当函数需要传递一个可修改的临时对象时。

- 在容器类中对元素进行重新分配或复制操作时，如果对象是可移动的，则移动构造函数将被调用。


## 虚函数和虚函数表

- 虚函数实现运行时多态，在该类对象中有一个 vptr，指向 vptbl
- 通过 vptr 查找 vptbl，通过 vptbl 中的函数地址来执行相应函数


## 抽象类和纯虚函数

抽象类是不能实例化的类，目的是为了提供接口，至少包含一个纯虚函数，virtual …… =0


## 虚析构和虚构造

### 1. 虚析构
- 在通过基类指针或引用删除派生类对象时，能够正确调用派生类的析构函数，从而释放对象所占的资源，需要将基类的析构函数声明为虚析构函数

- 指针是基类指针，虽然指向派生类对象，但是调用析构，如果没有 virtual，首先调用基类的

### 2. 虚构造
- 构造函数在对象创建阶段被调用，类型确定，没有多态，所以不需要虚构造

- 虚函数表在调用构造函数后才建立，所以不需要虚构造


## 不能被声明虚函数的

- 非成员函数

只能重载，编译阶段会绑定函数

- 静态成员函数

每个类共享一份代码

- 内联成员函数

inline 在编译时展开

- 构造函数

虚函数表在构造函数之后生成

- 友元函数

友元函数不会被继承

## 深浅拷贝

### 1. 深拷贝
- 不仅复制对象的值，还复制对象所指堆上的数据
- 自己动手实现拷贝构造和拷贝赋值


### 2. 浅拷贝
- 仅仅复制值，对于动态分配的资源，共享
- 默认的拷贝构造和拷贝赋值



## 运算符重载

二元运算符的第一个操作数类型不是本类，则必须非成员重载（使用友元函数）

```C++
// 比如 << 第一个操作数类型是 ostream
friend std::ostream& operator<<(std::ostream& os, const Time& t);
```

## 类对象的大小受到什么影响

- 类的非静态成员变量大小

- 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；

- 虚函数的话，会在类对象插入vptr指针，加上指针大小；

- 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。

- 静态成员不占据类的空间，成员函数也不占据类的空间大小；



