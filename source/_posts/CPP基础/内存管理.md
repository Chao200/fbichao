---
title: 内存管理
tags:
  - CPP
  - 内存管理
author: fbichao
categories: 
  - CPP
excerpt: 内存管理
math: true
date: 2024-03-22 21:45:00
---

## 堆栈区别

- 都用于存储数据

- 栈的大小有限，用于存储局部变量、函数调用
- 栈上变量的声明周期与其所在函数的执行周期一致
- 自动

- 堆是一种动态分配的内存区域
- 堆上变量声明周期由程序员显式控制
- 手动

## C++ 内存分区/内存管理

![](https://file.fbichao.top/2024/03/70d9b3a2f0af9f557da95607b02a7a25.png)

代码段 ---> 数据段（常量区 + 全局数据段[全局变量和静态变量]）---> 堆 ---> 栈


## 什么是内存池

如果直接通过 new 或 malloc 申请内存，那么每次都需要申请释放归还操作系统，为了提高效率，预先分配一些内存留作备用，释放时并不归还 OS，如果不够，再继续申请


## 内存泄露和避免

### 1. 内存泄露

指的是程序未能释放掉不再使用的内存，失去了对该段内存的控制

### 2. 分类

- 堆内存泄露
- 系统资源泄露
- 没有将基类的析构函数声明为虚函数

### 3. 避免

- 将内存的分配和释放封装在类的构造函数和析构函数
- 使用智能指针



## 智能指针

> 用于动态内存管理，避免内存泄露

### 1. unique_ptr

- 对动态分配的单一对象独占管理，确保只有一个指针可以拥有指定的内存资源
- 移动语义和右值引用可以高效转移

```C++
#include<memory>
std::unique_ptr<int> ptr = make_unique<int>(42);
```

### 2. shared_ptr

- 允许多个智能指针指向同一块内存资源
- 通过引用计数来跟踪被共享的次数，计数为 0 时，释放资源
- 存在循环引用的问题

```C++
#include<memory>
std::shared_ptr<int> ptr = make_shared<int>(42);
```

### 3. weak_ptr

- 为了解决 shared_ptr 的循环引用问题
- 可以从 shared_ptr 创建，但是不增加引用计数，并且不影响资源的释放

```C++
#include<memory>
std::shared_ptr<int> ptr = make_shared<int>(42);
std::weak_ptr<int> ptr2 = ptr;
```


## new 和 malloc

### 1. new

- new 是 C++ 的运算符，动态分配内存时会调用构造函数
- 返回的是具体指针类型，无序转换
- 分配失败抛出异常 std::bad_alloc


### 2. malloc

- C 语言库函数，只分配指定大小的内存块，不会调用析构函数
- 返回是 void*，需要类型转换
- 失败返回 NULL




## delete 和 free


### 1. delete

- 会调用对象的析构函数
- 释放的内存块指针值被设置为 nullptr，避免野指针


### 2. free

- 只简单释放内存，不调用析构函数
- 不会修改指针的值，可能导致野指针





## 野指针和悬浮指针

### 1. 野指针

- 野指针是指已被释放的或无效的内存地址的指针

#### 产生野指针

1. 释放后没置空
2. 返回局部变量的指针
3. 将通过参数传递的指针释放

#### 避免野指针

1. 释放后置空
2. 避免返回局部变量的指针
3. 避免通过参数释放指针
4. 使用智能指针

### 2. 悬浮指针

悬浮指针是指向**已销毁**的对象的引用

- 返回局部变量的引用


> 野指针设计指针类型，悬浮指针设计引用类型

## 内存对齐




## 类中数据分布

- 成员变量：栈
- 静态成员变量：全局数据段
- 成员函数和静态成员函数：代码区

## this

- 常量指针

- this 指针是指向类的对象首地址的指针

- this 指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this

- this 在成员函数的开始执行前构造，在成员的执行结束后清除。

- this 指针会因编译器不同而有不同的放置位置

- delete this 后，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题

- 析构函数调用 delete this，导致堆栈溢出，delete 会调用析构，析构会调用 delete，无限循环






