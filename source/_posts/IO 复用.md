---
title: IO 复用
tags:
  - IO 复用
  - select/poll/epoll
author: fbichao
categories: 
  - 操作系统
  - 并发
excerpt: IO 复用
math: true
date: 2024-03-12 21:45:00
---
# 1. 什么是 IO 多路复用

IO 多路复用时五种 IO 模型中的一个，一般通过 select、poll、epoll 实现

IO 多路复用是在一个进程或线程中处理多个输入和输出操作的机制，避免创建多个进程或线程的开销，允许单个进程同时监视多个文件描述符，当一个或多个文件描述符准备好读或写时，可以立即响应

# 2. 五种 IO 模型

一个输入操作通常包括两个阶段：

* 阶段1：等待数据准备好（数据到达，复制到 `内核缓冲区`）
* 阶段2：从内核向进程复制数据（从内核缓冲区复制到 `进程缓存区`）

![](https://file.fbichao.top/2024/03/2a924ca86e41b74a7d13a3eacc62bc65.png)

## 2.1 阻塞式 I/O

应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。

并不会阻塞其它进程，所以 CPU 利用率比较高

![](https://file.fbichao.top/2024/03/ef27ff2cc3923814896271db4fdc8972.png)

## 2.2 非阻塞式 I/O

应用进程执行系统调用之后，内核返回一个**错误码**。应用进程可以继续执行，但是需要通过轮询来判断 IO 是否完成

由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。

![](https://file.fbichao.top/2024/03/5c62c3a4a102349f4d4cc792b7721b8a.png)

## 2.3 I/O 复用

使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为**可读**。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。

让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。

如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

![](https://file.fbichao.top/2024/03/89f460f73ef756ec86e2821a5c653fe2.png)

## 2.4 信号驱动 I/O

应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。

![](https://file.fbichao.top/2024/03/6a5df387dd520574c19220b739772045.png)

## 2.5 异步 I/O

应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成（copy 完成），而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

![](https://file.fbichao.top/2024/03/67ade4e94e16ee47bfb96d0217111527.png)

## 2.6 五大 I/O 模型比较

- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞
  - 非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞

* 异步 I/O：第二阶段应用进程不会阻塞

![](https://file.fbichao.top/2024/03/668dd8a4c0181003680d5c7b91d7f9c9.png)

# 3. select/poll/epoll

## 3.1 select

### 3.1.1 概要

- 可以监视多个文件描述符的读写和错误状态
- 效率随着文件描述符的增加而降低
- 遍历+每次调用 select 重设文件描述符，因为会清零

### 3.1.2 细节

- 两次遍历 + 两次拷贝
- 将文件描述符拷贝到内核
- 遍历有无事件产生
- 有事件产生，从内核拷贝回进程
- 遍历找到发生变化的描述符

## 3.2 poll

- 是 select 的改进，采用轮询方式查看文件描述符状态，改进了 select 中文件描述符数量限制的问题，但是当有大量文件描述符时，效率依然低
- 动态数组，链表形式，遍历实际使用的文件描述符集合，而不是全部

## 3.3 epoll（红黑树）

- 是 Linux 特有的 IO 多路复用机制
- 相较于 select 和 poll，处理大量文件更高效
- 基于事件通知，不需要轮询，只有在文件描述符就绪时才通知应用程序
- 动态数据结构

### 触发模式

#### 条件/水平触发模式 LT

只要输入缓冲区有数据就一直通知该事件

#### 边缘触发模式 ET

输入缓冲区收到数据仅注册一次该该事件，即使还有数据，也不会再注册

**可以分离接收数据和处理数据的时间点**

> 条件触发也可以分离，但是如果输入缓冲有数据，而不读取，每次都会产生相应事件，事件会累加

# 4. select 和 epoll 区别

- select 和 poll 都采用轮询，时间复杂度为 $O(N)$
- epoll 采用回调方式，只返回事件发生的描述符个数，时间复杂度 $O(1)$
- select 只在低效的 LT 模式，epoll 则可以 ET
- epoll 只有 Linux
- 文件描述符数量
- select 需要在用户和内核 copy 数据，而 epoll 共享内存
