---
title: 锁
tags:
  - 锁
  - 死锁
author: fbichao
categories: 
  - 操作系统
  - 并发
excerpt: 锁、死锁
math: true
date: 2024-03-31 21:45:00
---

# 基本的锁

- 互斥锁：只有两种状态，上锁和解锁，互斥锁加锁失败，线程会释放 CPU 给其它线程
- 自旋锁：得不到锁会忙等待，一直轮询尝试获取锁

其余锁都是基于这两个锁

- 读写锁：多个线程可以同时读共享资源，只允许一个线程写资源
- 悲观锁：认为多线程同时修改临界资源概率较大，每次访问都要上锁
- 乐观锁：先不管，先修改资源，如果出现同时修改的情况，放弃本次操作

# 死锁「4个」必要条件

![](https://file.fbichao.top/2024/03/5be4061d42531f9f317d35a9ef17fa39.png)

> 方框表示资源，圆圈表示进程

* **互斥**：多个线程不能同时使用一个共享资源
* **占有和等待**：线程持有资源还会等待其他所需资源，不会主动释放
* **不可抢占**：无法抢占别的线程持有的资源
* **环路等待**：多个线程获取资源的顺序构成环路资源。

# 如何解除死锁

> 此时已经产生死锁，需要破坏上面四个条件之一

## 1. 互斥

完全避免互斥

设计无等待数据结构，通过硬件指令，构造出不需要锁的数据结构

比较并交换（compare and swap）指令
同样可能会产生活锁问题

## 2. 占有和等待

一次申请所有需要的资源

## 3. 不可抢占

调用 trylock() 函数尝试获得锁，如果得不到，就释放自身占有的锁

活锁问题：一直循环占有一个锁，随后释放
解决活锁：循环结束，设置一个随机的等待时间

## 4. 循环等待

让线程获取资源按照一定顺序，~~即全序、偏序~~

通过锁的地址顺序，比如按照地址从高到低顺序加锁


# 避免死锁

> 此时死锁未发生

通过调度，银行家算法，如果当前对资源的操作，导致后续会产生死锁，则回退

# 总结

有两种基本的锁，即自旋锁和互斥锁，可以产生读写锁、悲观锁、乐观锁

死锁就是多个进程占用了部分资源，同时又需要别的进程占有的资源，形成环路等待

形成死锁需要四个必要条件：1. 互斥；2. 占有等待；3. 不可剥夺；4. 环路等待

死锁产生后，需要破坏对应的四个条件中的一个即可

为了避免死锁，有银行家算法
